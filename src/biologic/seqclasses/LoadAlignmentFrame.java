/*
 *  Armadillo Workflow Platform v1.0
 *  A simple pipeline system for phylogenetic analysis
 *  
 *  Copyright (C) 2009-2011  Etienne Lord, Mickael Leclercq
 *
 *  This program is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 * 
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the 
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */

package biologic.seqclasses;

import biologic.Alignment;
import biologic.InfoAlignment;
import biologic.InfoSequence;
import biologic.MultipleAlignments;
import biologic.MultipleSequences;
import biologic.Sequence;
import biologic.seqclasses.SearchGenbank;
import biologic.seqclasses.StandardInputSequenceJDialog;
import configuration.Util;
import biologic.seqclasses.*;
import configuration.Config;
import configuration.SequenceFilter;
import database.databaseFunction;
import iubio.readseq.BioseqFormats;
import iubio.readseq.BioseqWriterIface;
import iubio.readseq.Readseq;
import java.awt.Color;
import java.awt.Dimension;
import java.awt.Toolkit;
import java.awt.event.WindowAdapter;
import java.awt.event.WindowEvent;
import java.beans.PropertyChangeEvent;
import java.beans.PropertyChangeListener;
import javax.swing.JFileChooser;
import java.util.Vector;
import javax.swing.JOptionPane;
import javax.swing.SwingWorker;
import java.io.*;
import java.util.LinkedList;
import java.util.List;
import java.util.regex.Matcher;
import java.util.regex.Pattern;
import javax.swing.DefaultComboBoxModel;
import javax.swing.JTextField; 
import tools.Toolbox;

/**
 * This is a JFrame displayed to the user so he can easily download and organize
 * alignments in group
 * @author Etienne Lord et Mickael Leclercq
 * @since July 2009
 */
public class LoadAlignmentFrame extends javax.swing.JFrame {

    static LoadAlignmentFrame main;                       //This is this mainframe gui
                                                        // Note: needed by various SwingWorker
    Config config=new Config();                         //Configuration file
    SwingWorker<Integer, InfoAlignment>  loadSwingWorker; //SwingWorker to import sequence
    SwingWorker<Integer, Object>  loadSwingWorker2;     //SwingWorker to import sequence
    SwingWorker<Integer, Object> runSwingWorker;        //SwingWorker to run analysis
    InformationJDialog loading;                        //Loading sequence JDialog
    private boolean stateSelected=false;             //do we Select or Unselect
    boolean runAnalysis=false;                      //RUN ANALYSIS Button is green because analysis is not started
    //This is a list of all the sequence in the database
    Vector<InfoAlignment>MultipleInfoAlignment=new Vector<InfoAlignment>();

    //--Database function
    databaseFunction df=new databaseFunction();

    //--Search function
    // Search
    String lastSearch="";
    static final int MODE_ID=0;
    static final int MODE_ACCESSION=1;
    static final int MODE_DESC=2;
    static final int MODE_ALIASES=3;
    static final int MODE_ALL=4;
    static final int MODE_LENMORE=6;
    static final int MODE_LENLESS=7;

    //--Return sequence_id
    //--Note: Used if we need to choose a single sequence
    public static final int MODE_NORMAL=0;
    public static final int MODE_SELECTION=1;

    public int return_sequence_id=0;
    public int status=Config.status_idle;

    /** Creates new form NewJFrame */
    public LoadAlignmentFrame(int mode) {
        initComponents();
        if (mode==MODE_SELECTION) {
            this.jTable1.setSelectionMode(javax.swing.ListSelectionModel.SINGLE_SELECTION);
            this.Close_jButton.setText("Select");
        }
         addWindowListener(new WindowAdapter() {
            @Override
        public void windowClosing(WindowEvent we) {
             status=Config.status_done;
            //--Update database Swing worker
            updateInfoAlignment();
        }
        });
        this.setIconImage(config.image);
        Dimension screenSize = Toolkit.getDefaultToolkit().getScreenSize();
        Dimension d = getSize();
        setLocation((screenSize.width-d.width)/2,
					(screenSize.height-d.height)/2);
    }

    /** This method is called from within the constructor to
     * initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is
     * always regenerated by the Form Editor.
     */
    @SuppressWarnings("unchecked")
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        Sequence_Panel = new javax.swing.JPanel();
        jPanel29 = new javax.swing.JPanel();
        jScrollPane1 = new javax.swing.JScrollPane();
        jTable1 = new javax.swing.JTable();
        SelectUnselectSequence_jButton = new javax.swing.JButton();
        RemoveSequence_jButton = new javax.swing.JButton();
        Close_jButton = new javax.swing.JButton();
        Filter_ComboBox = new javax.swing.JComboBox();
        jLabel1 = new javax.swing.JLabel();
        MakeCollectionjButton = new javax.swing.JButton();
        jStatusMessageSequence = new javax.swing.JTextField();
        RemoveFromGroupSequence_jButton = new javax.swing.JButton();
        jMenuBar1 = new javax.swing.JMenuBar();
        jMenu1 = new javax.swing.JMenu();
        jMenuItem3 = new javax.swing.JMenuItem();
        jMenuItem1 = new javax.swing.JMenuItem();
        jMenu2 = new javax.swing.JMenu();
        jMenuItem4 = new javax.swing.JMenuItem();
        SelectUnselectSequence_jMenuItem = new javax.swing.JMenuItem();
        jMenuItem2 = new javax.swing.JMenuItem();

        setDefaultCloseOperation(javax.swing.WindowConstants.DO_NOTHING_ON_CLOSE);
        setTitle("Alignment Manager");
        setResizable(false);
        addWindowListener(new java.awt.event.WindowAdapter() {
            public void windowClosed(java.awt.event.WindowEvent evt) {
                formWindowClosed(evt);
            }
        });

        Sequence_Panel.setBackground(new java.awt.Color(255, 255, 255));
        Sequence_Panel.addFocusListener(new java.awt.event.FocusAdapter() {
            public void focusGained(java.awt.event.FocusEvent evt) {
                Sequence_PanelFocusGained(evt);
            }
        });

        jPanel29.setBackground(new java.awt.Color(255, 255, 255));
        jPanel29.setBorder(javax.swing.BorderFactory.createTitledBorder("Alignments and informations"));

        jScrollPane1.setBackground(new java.awt.Color(255, 255, 255));
        jScrollPane1.setHorizontalScrollBarPolicy(javax.swing.ScrollPaneConstants.HORIZONTAL_SCROLLBAR_ALWAYS);

        jTable1.setAutoCreateRowSorter(true);
        jTable1.setModel(new InfoAlignmentTableModel());
        jTable1.setSelectionMode(javax.swing.ListSelectionModel.MULTIPLE_INTERVAL_SELECTION);
        jTable1.addMouseListener(new java.awt.event.MouseAdapter() {
            public void mouseClicked(java.awt.event.MouseEvent evt) {
                jTable1MouseClicked(evt);
            }
        });
        jTable1.addKeyListener(new java.awt.event.KeyAdapter() {
            public void keyReleased(java.awt.event.KeyEvent evt) {
                jTable1KeyReleased(evt);
            }
        });
        jScrollPane1.setViewportView(jTable1);

        SelectUnselectSequence_jButton.setText("Select / Unselect");
        SelectUnselectSequence_jButton.setToolTipText("<html>Select or Unselect the current results selection. <br>If nothing is selected, select or unselect all the results</html>");
        SelectUnselectSequence_jButton.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                SelectUnselectSequence_jButtonActionPerformed(evt);
            }
        });

        RemoveSequence_jButton.setText("Remove");
        RemoveSequence_jButton.setToolTipText("<html>Remove current selected sequences from the database<br></html>");
        RemoveSequence_jButton.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                RemoveSequence_jButtonActionPerformed(evt);
            }
        });

        Close_jButton.setText("Close");
        Close_jButton.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                Close_jButtonActionPerformed(evt);
            }
        });

        Filter_ComboBox.setEditable(true);
        Filter_ComboBox.setModel(new javax.swing.DefaultComboBoxModel(Config.ClusteringOption));
        Filter_ComboBox.setToolTipText("Filter your results. Enter a search string");
        Filter_ComboBox.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                Filter_ComboBoxActionPerformed(evt);
            }
        });

        jLabel1.setText("Filter your sequences");

        MakeCollectionjButton.setText("Make Group");
        MakeCollectionjButton.setToolTipText("This will make a new MultipleSequences group from the selected sequences");
        MakeCollectionjButton.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                MakeCollectionjButtonActionPerformed(evt);
            }
        });

        jStatusMessageSequence.setText("jTextField1");
        jStatusMessageSequence.setBorder(null);

        RemoveFromGroupSequence_jButton.setText("Remove from Group");
        RemoveFromGroupSequence_jButton.setToolTipText("<html>Remove current selected sequences from the database<br></html>");
        RemoveFromGroupSequence_jButton.setEnabled(false);
        RemoveFromGroupSequence_jButton.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                RemoveFromGroupSequence_jButtonActionPerformed(evt);
            }
        });

        javax.swing.GroupLayout jPanel29Layout = new javax.swing.GroupLayout(jPanel29);
        jPanel29.setLayout(jPanel29Layout);
        jPanel29Layout.setHorizontalGroup(
            jPanel29Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(jPanel29Layout.createSequentialGroup()
                .addComponent(jLabel1)
                .addContainerGap())
            .addGroup(jPanel29Layout.createSequentialGroup()
                .addContainerGap()
                .addComponent(Filter_ComboBox, 0, 740, Short.MAX_VALUE)
                .addContainerGap())
            .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, jPanel29Layout.createSequentialGroup()
                .addContainerGap()
                .addComponent(SelectUnselectSequence_jButton, javax.swing.GroupLayout.PREFERRED_SIZE, 133, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(RemoveSequence_jButton)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED, 251, Short.MAX_VALUE)
                .addComponent(RemoveFromGroupSequence_jButton)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(MakeCollectionjButton)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(Close_jButton))
            .addGroup(jPanel29Layout.createSequentialGroup()
                .addContainerGap()
                .addComponent(jStatusMessageSequence, javax.swing.GroupLayout.DEFAULT_SIZE, 740, Short.MAX_VALUE)
                .addContainerGap())
            .addComponent(jScrollPane1, javax.swing.GroupLayout.DEFAULT_SIZE, 760, Short.MAX_VALUE)
        );
        jPanel29Layout.setVerticalGroup(
            jPanel29Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(jPanel29Layout.createSequentialGroup()
                .addComponent(jLabel1)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(Filter_ComboBox, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(jScrollPane1, javax.swing.GroupLayout.DEFAULT_SIZE, 371, Short.MAX_VALUE)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(jStatusMessageSequence, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addGroup(jPanel29Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                    .addComponent(Close_jButton)
                    .addComponent(MakeCollectionjButton)
                    .addComponent(SelectUnselectSequence_jButton)
                    .addComponent(RemoveSequence_jButton)
                    .addComponent(RemoveFromGroupSequence_jButton)))
        );

        javax.swing.GroupLayout Sequence_PanelLayout = new javax.swing.GroupLayout(Sequence_Panel);
        Sequence_Panel.setLayout(Sequence_PanelLayout);
        Sequence_PanelLayout.setHorizontalGroup(
            Sequence_PanelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(Sequence_PanelLayout.createSequentialGroup()
                .addContainerGap()
                .addComponent(jPanel29, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                .addContainerGap())
        );
        Sequence_PanelLayout.setVerticalGroup(
            Sequence_PanelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(Sequence_PanelLayout.createSequentialGroup()
                .addContainerGap()
                .addComponent(jPanel29, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addContainerGap(16, Short.MAX_VALUE))
        );

        jMenu1.setText("File");

        jMenuItem3.setText("Add new alignment");
        jMenuItem3.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jMenuItem3ActionPerformed(evt);
            }
        });
        jMenu1.add(jMenuItem3);

        jMenuItem1.setAccelerator(javax.swing.KeyStroke.getKeyStroke(java.awt.event.KeyEvent.VK_S, java.awt.event.InputEvent.CTRL_MASK));
        jMenuItem1.setText("Save selected alignments");
        jMenuItem1.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jMenuItem1ActionPerformed(evt);
            }
        });
        jMenu1.add(jMenuItem1);

        jMenuBar1.add(jMenu1);

        jMenu2.setText("Edit");
        jMenu2.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jMenu2ActionPerformed(evt);
            }
        });

        jMenuItem4.setText("Remove");
        jMenuItem4.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                RemoveSequence_jButtonActionPerformed(evt);
            }
        });
        jMenu2.add(jMenuItem4);

        SelectUnselectSequence_jMenuItem.setText("Select/Unselect");
        SelectUnselectSequence_jMenuItem.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                SelectUnselectSequence_jMenuItemActionPerformed(evt);
            }
        });
        jMenu2.add(SelectUnselectSequence_jMenuItem);

        jMenuItem2.setText("Make new group");
        jMenuItem2.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jMenuItem2ActionPerformed(evt);
            }
        });
        jMenu2.add(jMenuItem2);

        jMenuBar1.add(jMenu2);

        setJMenuBar(jMenuBar1);

        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(getContentPane());
        getContentPane().setLayout(layout);
        layout.setHorizontalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addComponent(Sequence_Panel, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
        );
        layout.setVerticalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addComponent(Sequence_Panel, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
        );

        pack();
    }// </editor-fold>//GEN-END:initComponents

    private void RemoveSequence_jButtonActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_RemoveSequence_jButtonActionPerformed
        InfoSequenceTableModel tm=(InfoSequenceTableModel)this.jTable1.getModel();
        //What do we do?
        //--First get the right selection
//        int[] indexSelection=this.jTable1.getSelectedRows();
//        for (int i=0;i<indexSelection.length;i++) {
//            indexSelection[i]=this.jTable1.convertRowIndexToModel(indexSelection[i]);
//        }
        //--Ok, by default, if we have a selection (but not checked, we remove the selection...
        String msg="<html>Do you really want to remove "+getNumberSelected()
                +" alignments from database?</html>";
        Object[] options = {"Yes","Cancel"};
        int choice = JOptionPane.showOptionDialog(this,msg,"Warning! Remove Alignments from Project",JOptionPane.YES_NO_OPTION,JOptionPane.WARNING_MESSAGE,null,options, options[0]);
        //choice==0 [YES] We remove
        if (choice==0) {
            //Case 1: we remove the current displayed selected sequence            
            for (InfoAlignment s:MultipleInfoAlignment) if (s.isSelected()) s.setSelected_for_remove(true);
            //Actual remove
            Vector<InfoAlignment> toRemove=new Vector<InfoAlignment>();
            for (int i=MultipleInfoAlignment.size()-1;i>-1;i--) {
                InfoAlignment s=MultipleInfoAlignment.get(i);
                if (s.isSelected_for_remove()) {
                    toRemove.add(s);
                }
            }
            RemoveAlignments(toRemove);
      
      } //End choice ==0 We remove
}//GEN-LAST:event_RemoveSequence_jButtonActionPerformed

    private void SelectUnselectSequence_jButtonActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_SelectUnselectSequence_jButtonActionPerformed
        InfoAlignmentTableModel tm=(InfoAlignmentTableModel)this.jTable1.getModel();
        //What do we do?
        int[] index=this.jTable1.getSelectedRows();
        //CAS 1. On met tout a select ou unselect
        if (index.length==0) {
            for (InfoAlignment s:tm.data) s.setSelected(stateSelected);
            stateSelected=!stateSelected;
        } else {
            //CAS 2. Inversion de la sélection
            for (int i:index) {
                i=this.jTable1.convertRowIndexToModel(i);
                tm.data.get(i).setSelected(!tm.data.get(i).isSelected());
            }

        }
        tm.fireTableDataChanged();
        this.jTable1.setModel(tm);
}//GEN-LAST:event_SelectUnselectSequence_jButtonActionPerformed

    private void Filter_ComboBoxActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_Filter_ComboBoxActionPerformed
        this.RemoveFromGroupSequence_jButton.setEnabled(false);
        //Update the displayed data in the table
        InfoAlignmentTableModel tm=(InfoAlignmentTableModel)this.jTable1.getModel();
        //Remove previous selection
         for (InfoAlignment s:tm.data) s.setSelected(false);
        //
        int mode=this.Filter_ComboBox.getSelectedIndex();
        int count=0; //--ResultCound
        String searchString=(String)this.Filter_ComboBox.getSelectedItem();
        if (mode==0) {
            //--Reset the table
            tm.data.clear();
            tm.setData(MultipleInfoAlignment);
                        Message("Found "+MultipleInfoAlignment.size()+" alignment(s)","", this.jStatusMessageSequence);
        } else {
            if (searchString.startsWith(">")) {
               String s=searchString.substring(1);
               Vector<Integer> resultIndex=search(s, LoadAlignmentFrame.MODE_LENMORE);
                count=resultIndex.size();
                tm.data.clear();
                for (Integer index:resultIndex) {
                    tm.addData(MultipleInfoAlignment.get(index));
                }
                Message("Found "+resultIndex.size()+" alignment(s)","",this.jStatusMessageSequence);

            } else
            if (searchString.startsWith("<")) {
               String s=searchString.substring(1);
               Vector<Integer> resultIndex=search(s, LoadAlignmentFrame.MODE_LENLESS);
                count=resultIndex.size();
                tm.data.clear();
                for (Integer index:resultIndex) {
                    tm.addData(MultipleInfoAlignment.get(index));
                }
                Message("Found "+resultIndex.size()+" alignment(s)","",this.jStatusMessageSequence);

            } else          
             if (searchString.startsWith("MultipleAlignments:")) {
               this.RemoveFromGroupSequence_jButton.setEnabled(true);
                //-- We select only the sequence of a particular group...
               //--Get the ID
                String IDS=searchString.substring(searchString.indexOf(" ")+1, searchString.indexOf("\t"));
                int ID=0;
                try {
                    ID=Integer.valueOf(IDS);
                } catch(Exception e) {ID=0;}
                tm.data.clear();
                Vector<Integer> resultIndex=df.getSequenceIDinAlignment(ID);
                count=resultIndex.size();
                for (InfoAlignment S:MultipleInfoAlignment) {
                    if (resultIndex.contains(S.getId())) {
                        tm.addData(S);
                    }
                }
                Message("Found "+df.getSequenceIDinAlignment(ID).size()+" alignment(s)","",this.jStatusMessageSequence);
            }
            else {
               //--Normal search
            Vector<Integer> resultIndex=search(searchString, LoadAlignmentFrame.MODE_ALL);
            count=resultIndex.size();
            tm.data.clear();
            for (Integer index:resultIndex) {
                tm.addData(MultipleInfoAlignment.get(index));
            }
                Message("Found "+resultIndex.size()+" alignment(s)","",this.jStatusMessageSequence);
            }
        }
        
        tm.fireTableDataChanged();
        this.jTable1.setModel(tm);
}//GEN-LAST:event_Filter_ComboBoxActionPerformed

    private void jTable1MouseClicked(java.awt.event.MouseEvent evt) {//GEN-FIRST:event_jTable1MouseClicked
        displaySelectedSequence();
}//GEN-LAST:event_jTable1MouseClicked

    private void jTable1KeyReleased(java.awt.event.KeyEvent evt) {//GEN-FIRST:event_jTable1KeyReleased
        displaySelectedSequence();
}//GEN-LAST:event_jTable1KeyReleased

    private void Sequence_PanelFocusGained(java.awt.event.FocusEvent evt) {//GEN-FIRST:event_Sequence_PanelFocusGained
//        String msg=String.format("%d sequence(s) in project", project.MultipleSequenceList.getNbSequence());
//                Message(msg,"",this.jStatusMessageSequence);
}//GEN-LAST:event_Sequence_PanelFocusGained

    private void Close_jButtonActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_Close_jButtonActionPerformed
        status=Config.status_done;
        //--Update database Swing worker
       this.updateInfoAlignment();
}//GEN-LAST:event_Close_jButtonActionPerformed

    private void SelectUnselectSequence_jMenuItemActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_SelectUnselectSequence_jMenuItemActionPerformed
        InfoAlignmentTableModel tm=(InfoAlignmentTableModel)this.jTable1.getModel();
        //What do we do?
        int[] index=this.jTable1.getSelectedRows();
        //CAS 1. On met tout a select ou unselect
        if (index.length==0) {
            for (InfoAlignment s:tm.data) s.setSelected(stateSelected);
            stateSelected=!stateSelected;
        } else {
            //CAS 2. Inversion de la sélection
            for (int i:index) {
                i=this.jTable1.convertRowIndexToModel(i);
                tm.data.get(i).setSelected(!tm.data.get(i).isSelected());
            }

        }
        tm.fireTableDataChanged();
        this.jTable1.setModel(tm);
}//GEN-LAST:event_SelectUnselectSequence_jMenuItemActionPerformed

    private void MakeCollectionjButtonActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_MakeCollectionjButtonActionPerformed
    makeGroup();
}//GEN-LAST:event_MakeCollectionjButtonActionPerformed

    private void formWindowClosed(java.awt.event.WindowEvent evt) {//GEN-FIRST:event_formWindowClosed
        status=Config.status_done;
    }//GEN-LAST:event_formWindowClosed

    private void jMenuItem1ActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jMenuItem1ActionPerformed
       saveSelection();
    }//GEN-LAST:event_jMenuItem1ActionPerformed

    private void jMenuItem2ActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jMenuItem2ActionPerformed
        // TODO add your handling code here:
    }//GEN-LAST:event_jMenuItem2ActionPerformed

    private void jMenu2ActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jMenu2ActionPerformed
        makeGroup();
    }//GEN-LAST:event_jMenu2ActionPerformed

    private void jMenuItem3ActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jMenuItem3ActionPerformed
       SimpleInputJDialog si=new SimpleInputJDialog(this, true, "Alignment");
       if (si.isAdded()) this.loadInfoAlignment();
    }//GEN-LAST:event_jMenuItem3ActionPerformed

    private void RemoveFromGroupSequence_jButtonActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_RemoveFromGroupSequence_jButtonActionPerformed
        String searchString=(String)this.Filter_ComboBox.getSelectedItem();
        int index= this.Filter_ComboBox.getSelectedIndex();
        //Update the displayed data in the table
        InfoAlignmentTableModel tm=(InfoAlignmentTableModel)this.jTable1.getModel();
        tm.data.clear();
//        if (searchString.startsWith("MultipleSequences:")) {
//               //-- We select only the sequence of a particular group...
//               //--Get the ID
//                String IDS=searchString.substring(searchString.indexOf(" ")+1, searchString.indexOf("\t"));
//                int ID=0;
//                try {
//                    ID=Integer.valueOf(IDS);
//                } catch(Exception e) {ID=0;}
//                Vector<Integer> resultIndex=df.getSequenceIDinMultipleSequence(ID);
//                MultipleSequences multi=new MultipleSequences(ID);
//                for (InfoSequence S:MultipleInfoSequence) {
//                    if (resultIndex.contains(S.getId())&&S.isSelected()) {
//                        multi.removeSequence(S.getId());
//                    } else tm.addData(S);
//                }
//
//                Message("Found "+df.getSequenceIDinMultipleSequence(ID).size()+" sequence(s)","",this.jStatusMessageSequence);
//        }
        if (searchString.startsWith("MultipleAlignments:")) {
               //-- We select only the sequence of a particular group...
               //--Get the ID
                String IDS=searchString.substring(searchString.indexOf(" ")+1, searchString.indexOf("\t"));
                int ID=0;
                try {
                    ID=Integer.valueOf(IDS);
                } catch(Exception e) {ID=0;}
                Vector<Integer> resultIndex=df.getAlignmentIDinMultipleAlignments(ID);
                MultipleAlignments multi=new MultipleAlignments(ID);
                for (InfoAlignment A:MultipleInfoAlignment) {
                    if (resultIndex.contains(A.getId())&&A.isSelected()) {
                        multi.removeAlignment(A.getId());
                    } else tm.addData(A);
                }

                Message("Found "+df.getSequenceIDinAlignment(ID).size()+" alignment(s)","",this.jStatusMessageSequence);
        }
        tm.fireTableDataChanged();
        this.jTable1.setModel(tm);
        this.Filter_ComboBox.setModel(new DefaultComboBoxModel(Config.ClusteringOption));
        for (String S: df.getGroup()) this.Filter_ComboBox.addItem(S);
        for (String S: df.getAlignmentGroup()) this.Filter_ComboBox.addItem(S);
        this.Filter_ComboBox.setSelectedIndex(index);
    }//GEN-LAST:event_RemoveFromGroupSequence_jButtonActionPerformed

    
        /**
     * Affiche un message dans la status bar
     * La provenance peut être mise dans un tooltip
     * @param text Le texte
     * @param tooltip Le tooltip texte
     */
    void Message(String text, String tooltip, JTextField jStatusMessage) {
        jStatusMessage.setEnabled(true);
        jStatusMessage.setForeground(new java.awt.Color(0, 51, 153));
        jStatusMessage.setBackground(Color.WHITE);
        jStatusMessage.setToolTipText(tooltip);
        jStatusMessage.setText(text);
    }

    /**
     * Affiche un message d'erreur en rouge dans la status bar
     * La provenance peut être mise dans un tooltip
     * @param text Le texte
     * @param tooltip Le tooltip texte
     */
    void MessageError(String text, String tooltip, JTextField jStatusMessage) {
        jStatusMessage.setEnabled(true);
        jStatusMessage.setForeground(Color.RED);
        jStatusMessage.setBackground(Color.WHITE);
        jStatusMessage.setToolTipText(tooltip);
        jStatusMessage.setText(text);
    }

    ////////////////////////////////////////////////////////////////////////////
/// JTable1

    /**
     * Simple Method to display selected sequence info in jInfo
     */
    void displaySelectedSequence() {
        int selection=this.jTable1.getSelectedRow();
        InfoAlignmentTableModel lm = (InfoAlignmentTableModel)this.jTable1.getModel();
        InfoAlignment tmp=lm.getInfoAlignment(selection);
        return_sequence_id=tmp.getId();
        Message(tmp.toString(), "", this.jStatusMessageSequence);
    }

    public void saveSelection() {
        InfoAlignmentTableModel tm=(InfoAlignmentTableModel)this.jTable1.getModel();
        //What do we do?
        //--First get the right selection
        int[] indexSelection=this.jTable1.getSelectedRows();
        for (int i=0;i<indexSelection.length;i++) {
            indexSelection[i]=this.jTable1.convertRowIndexToModel(indexSelection[i]);
        }
        //--No direct selection , look in the list
        //--TO DO: More beautiful code here
        if (indexSelection.length==0) {
           Vector<Integer>tmp=new Vector<Integer>();
           int count=0; 
           for (InfoAlignment info:tm.data) {
               if (info.isSelected()) tmp.add(count);
               count++;
           }
           count=0;
           indexSelection=new int[tmp.size()];
           for (Integer i:tmp) indexSelection[count++]=i;
        }
        //--Ok, by default, if we have a selection (but not checked, we remove the selection...
        if (indexSelection.length>0) {

        JFileChooser jf=new JFileChooser();
        jf.setName("Save selected sequences...");
        int result=jf.showSaveDialog(this);
            //CAS 1: On reussi a choisir un fichier
        if (result==JFileChooser.APPROVE_OPTION) {
             String filename=jf.getSelectedFile().getAbsolutePath().toLowerCase();
             MultipleSequences mus=new MultipleSequences();
             for (int indexInfoSequence:indexSelection) {
                 InfoAlignment info=tm.getInfoAlignment(indexInfoSequence);
                 Alignment s=new Alignment(info.getId());
                 mus.add(s);
             }
             if (filename.endsWith("phy")||filename.endsWith("phylip")) {
                 if (mus.outputPhylip(filename)) {
                     Message("Saved "+mus.getNbSequence()+" Alignment(s) to "+filename+" in Phylip non-interleaved format","",this.jStatusMessageSequence);
                 } else {
                     MessageError("Unable to save "+mus.getNbSequence()+" Alignment(s) to "+filename+" in Phylip non-interleaved format","",this.jStatusMessageSequence);
                 }
              } else {
                 if (mus.outputFasta(filename)) {
                    Message("Saved "+mus.getNbSequence()+" Alignment(s) to "+filename+" in Fasta format","",this.jStatusMessageSequence);
                 } else {
                     MessageError("Unable to save "+mus.getNbSequence()+" Alignment(s) to "+filename+" in Fasta format","",this.jStatusMessageSequence);
                 }
              } //End else
        } // End jfilechoose=Approve
        } else {
            MessageError("No sequences selected. Please select some sequences before saving them.","",this.jStatusMessageSequence);
        }
    } // End save selection

    public void makeGroup() {
         InfoAlignmentTableModel tm=(InfoAlignmentTableModel)this.jTable1.getModel();
        //What do we do?
            //--First get the right selection
//            int[] indexSelection=this.jTable1.getSelectedRows();
//            for (int i=0;i<indexSelection.length;i++) {
//                indexSelection[i]=this.jTable1.convertRowIndexToModel(indexSelection[i]);
//            }
//
//            //Case 1: we remove the current displayed selected sequence
//            if (indexSelection.length>0) {
//                //Mark for remove
//                for (Integer i:indexSelection) {
//                    InfoSequence s=MultipleInfoSequence.get(i);
//                    s.setSelected_for_grouping(true);
//                }
////            }
//            //Case 2: No active selection: select the selected sequence
//            else {
                for (InfoAlignment s:MultipleInfoAlignment) if (s.isSelected()) s.setSelected_for_grouping(true);
//            }

        StandardInputSequenceJDialog jd=new StandardInputSequenceJDialog(this, "New_Group_"+this.hashCode(),"Create", "MultipleAlignments");
        jd.setVisible(true);
        if (jd.getStatus()==Config.status_done) {
            MultipleAlignments multi=new MultipleAlignments();
            multi.setName(jd.getCollectionName());
            multi.setNote(jd.getComments());
            for (InfoAlignment s:MultipleInfoAlignment) {
                if (s.isSelected_for_grouping()) multi.add(s);
            }
            for (InfoAlignment s:MultipleInfoAlignment) s.setSelected_for_grouping(false);
            multi.saveToDatabase();
            updateUI();
        }
    }


    public void importSequenceFromDisk(){
        JFileChooser jf=new JFileChooser(config.getExplorerPath());
        jf.setMultiSelectionEnabled(true);
        jf.addChoosableFileFilter(new SequenceFilter());
        jf.setAcceptAllFileFilterUsed(false);
        int result=jf.showOpenDialog(this);


        //CAS 1: On reussi a choisir un fichier
        if (result==JFileChooser.APPROVE_OPTION) {
             String path=jf.getSelectedFile().getPath();
             config.setExplorerPath(path);
            File[] files=jf.getSelectedFiles();
            if (files.length>0) {
                String filename="";
                if (files.length==1) {
                    filename=files[0].getName()+"_"+this.hashCode();
                } else {
                    filename="Multiple_files_"+this.hashCode();
                }
                StandardInputSequenceJDialog jd=new StandardInputSequenceJDialog(this, filename,"Import", "MultipleSequences");
                jd.setVisible(true);
                if (jd.getStatus()==Config.status_done) {
                    loadSequenceFiles(files,jd.getCollectionName(),jd.getComments(), jd.getSequenceType());//load Files using a Swing worker
                }
            }
       } //End file
    }

    /**
     * Simple thread to load file into the project
     */
    public void loadSequenceFiles(final File[] files, final String groupname, final String note, final String type) {
        final LinkedList<File> toLoad=new LinkedList<File>();
        final int totalToLoad=files.length;
        for(File f:files) toLoad.add(f);
       
        SwingWorker<Integer, Object> loadSwingWorker2=new SwingWorker<Integer, Object>() {
            String filename="";
           
            @Override
            protected Integer doInBackground() throws Exception {
                //We dont check for cancelled

                while (!isCancelled()&&toLoad.size()>0) {
                    File f=toLoad.pollFirst();
                    filename=f.getAbsolutePath();
                    publish("Loading "+filename);
                    //--This is a duplicate of the code from MultipleSequence.loadSequenceFromFasta...
                    //--First. Conversion to fasta if not using ReadSeq
                    setProgress(0);
                   MultipleSequences multi=new MultipleSequences();
                   multi.setName(filename);
                   multi.setNote(note);
                    if (!filename.toLowerCase().endsWith("fasta")) {
                        publish("Converting to fasta...");
                        try {
                         int outid= BioseqFormats.formatFromName("fasta");
                            BioseqWriterIface seqwriter= BioseqFormats.newWriter(outid);
                            seqwriter.setOutput(new FileWriter("out.fasta"));
                            seqwriter.writeHeader();
                            Readseq rd= new Readseq();
                             rd.setInputObject(filename);
                             if (rd.isKnownFormat() && rd.readInit())
                             rd.readTo( seqwriter);
                            seqwriter.writeTrailer();                                                  
                        } catch(Exception e) {
                            Config.log("Unable to read "+filename+" using ReadSeq...");                            
                        }
                        filename="out.fasta";
                    }                   
                    //--Second. Actual reading
                  try {
                      multi.getSequences().clear(); //Clear the sequence vector and open the file
                      File file=new File(filename);
                      BufferedReader br =new BufferedReader(new FileReader(file));
                      long filesize=file.length();
                      long countsize=0;
                      
                      //VARIABLES
                      boolean sequenceMode=false;   
                      Sequence tmp = new Sequence();                        //Temp sequence
                      StringBuilder tmpsequence=new StringBuilder();        //Temp sequence string
                      String stri="";                                       //Temp read line
                      
                      //Read the file in a buffer an parse at the same time
                     //Process :: We read like a fasta file
                      Config.log("Reading fasta:"+filename+":");
                      
                      while (br.ready()) {
                          stri=br.readLine();
                          countsize+=stri.length();
                          //Config.log(stri);
                          if (sequenceMode&&(stri.equals("")||stri.startsWith(">"))) {
                              tmp.setSequence(tmpsequence.toString());
                              tmp.loadInfoFromName();
                              tmp.setSequence_type(type);
                              //Add sequence if not empty
                              if (tmp.getSequence().length()>0) multi.getSequences().add(tmp);
                              tmp=new Sequence();
                              tmpsequence=new StringBuilder();
                              sequenceMode=false;
                          } 
                          if (sequenceMode) {
                              tmpsequence.append(stri);
                              //--5% countter
                              int percent=(int) (countsize*100/filesize);
                              if (percent%5==0) {
                                  //Config.log("*");
                                  setProgress(percent);
                              }
                          } 
                          if (stri.startsWith(">")) {
                                //We have a fasta definition
                                tmp.setName(stri.substring(1)); //remove >
                                sequenceMode=true;
                          }

                      } //end while
                      //Add last read
                      if (sequenceMode) {
                          tmp.setSequence(tmpsequence.toString());
                          tmp.loadInfoFromName();
                          if (tmp.getSequence().length()>0) multi.getSequences().add(tmp);
                          tmp=new Sequence();
                      }
                      br.close();                      
                   } catch(Exception e) {e.printStackTrace();Config.log("Error with "+filename);}
                    Config.log("done.s");
                   publish("Saving to database...");
                    multi.saveToDatabase();
                    setProgress((totalToLoad-toLoad.size())*100/totalToLoad);
                    if (multi.getId()==0) {
                        publish("Unable to load sequence(s) from "+filename);
                    } else {
                        publish("Successfully imported sequence(s) from "+filename);
                    }
                 }
                return 0;
            }

            @Override
            public void process(List<Object> chunk) {
                for (Object o:chunk) {
                    if (o instanceof String)  {
                        String s=(String)o;
                        if (s.startsWith("Unable")||s.startsWith("Error")) {
                            loading.MessageErreur(s, "");
                        } else {
                            loading.Message(s,"");
                        } //--End Unable
                     } //--End instance of String
                } //--End list of Object
            } //End process

            @Override
            public void done() {
                loading.setVisible(false);
                //Update UI by reloading alll sequences... (to be sure)...
                loadInfoAlignment();
            }

        }; //End SwingWorker definition

        loadSwingWorker2.addPropertyChangeListener(
                 new PropertyChangeListener() {
                    public  void propertyChange(PropertyChangeEvent evt) {
                        if ("progress".equals(evt.getPropertyName())) {
                            SwingWorker o = (SwingWorker)evt.getSource();
                            if (!o.isDone()) {
                                int progress=(Integer)evt.getNewValue();
                                loading.setProgress(progress);
                            }
                            else if (o.isDone()&&!o.isCancelled()) {
                               //Handled in done() fucntion in SwingWorker
                            }
                        }//End progress update
                 } //End populateNetworkPropertyChange
                 });
        //Finally. Show a load dialog :: Warning Work-In-Progress
        loading=new InformationJDialog(this, false, loadSwingWorker2,"Loading files...");
        loading.setProgress(0); //Put 0% as the start progress
        loading.Message("Loading "+files.length+" files...", "");
        loadSwingWorker2.execute();


    }


  

////////////////////////////////////////////////////////////////////////////////
/// UI and Selection 

    /**
     *
     * @return the number of Selected Sequence
     */
    public int getNumberSelected() {
        int number=0;
        for (InfoAlignment s:MultipleInfoAlignment) {
            if (s.isSelected()) number++;
        }
        return number;
    }

 private void loadInfoAlignment() {
      MultipleInfoAlignment.clear();
      final Vector<Integer>alignments_id=df.getAllAlignmentID();
      final int size=alignments_id.size();
      SwingWorker<Integer, InfoAlignment> infoSwingWorker=new SwingWorker<Integer, InfoAlignment>()  {

       @Override
        protected Integer doInBackground() throws Exception {
        try {
            for (int i=0; i<size;i++) {
               InfoAlignment info=new InfoAlignment(alignments_id.get(i));
               publish(info);
               setProgress(i*100/size);
            }
        } catch(Exception e) {e.printStackTrace();}
                return 0;
            }

            //On update notre Table avec les resultats partiels
            @Override
            protected void process(List<InfoAlignment> chunks) {
                for (InfoAlignment data:chunks) {
                    MultipleInfoAlignment.add(data);
                }
            }


           @Override
           protected void done(){
                loading.setVisible(false);
                updateUI();
           }

        }; //End SwingWorker declaration

        infoSwingWorker.addPropertyChangeListener(
                 new PropertyChangeListener() {
                    public  void propertyChange(PropertyChangeEvent evt) {
                     if ("progress".equals(evt.getPropertyName())) {
                            SwingWorker o = (SwingWorker)evt.getSource();
                            if (!o.isDone()) {
                                int progress=(Integer)evt.getNewValue();
                                loading.setProgress(progress);
                            }
                            else if (o.isDone()&&!o.isCancelled()) {
                               //Handled in done() fucntion in SwingWorker
                            }
                        }//End progress update
                 } //End populateNetworkPropertyChange
                 });
        loading=new InformationJDialog(this, false, infoSwingWorker, "Loading alignment");
        loading.setProgress(0); //Put 0% as the start progress
        loading.Message("Loading "+size+" alignment information from database...", "");
        infoSwingWorker.execute();
    }

 private void updateInfoAlignment() {
     
      
      SwingWorker<Integer, InfoAlignment> infoSwingWorker=new SwingWorker<Integer, InfoAlignment>()  {

       @Override
        protected Integer doInBackground() throws Exception {
           int size=MultipleInfoAlignment.size();
           int count=0;
           try {
               for (InfoAlignment info:MultipleInfoAlignment) {
                if (info.isModified()) {
                   info.update();
                }
                setProgress(count++*100/size);
            }
            } catch(Exception e) {e.printStackTrace();}
                    return 0;
            }

            //On update notre Table avec les resultats partiels
            @Override
            protected void process(List<InfoAlignment> chunks) {

            }


           @Override
           protected void done(){
                loading.setVisible(false);
                setVisible(false);
                updateUI();
                Toolbox tool=new Toolbox();
                tool.reloadDatabaseTree();                
           }

        }; //End SwingWorker declaration

        infoSwingWorker.addPropertyChangeListener(
                 new PropertyChangeListener() {
                    public  void propertyChange(PropertyChangeEvent evt) {
                     if ("progress".equals(evt.getPropertyName())) {
                            SwingWorker o = (SwingWorker)evt.getSource();
                            if (!o.isDone()) {
                                int progress=(Integer)evt.getNewValue();
                                loading.setProgress(progress);
                            }
                            else if (o.isDone()&&!o.isCancelled()) {
                               //Handled in done() fucntion in SwingWorker
                            }
                        }//End progress update
                 } //End populateNetworkPropertyChange
                 });
        loading=new InformationJDialog(this, false, infoSwingWorker, "Updating alignments");
        loading.setProgress(0); //Put 0% as the start progress
        loading.Message("Updating alignment information in database...", "");
        infoSwingWorker.execute();
    }

 private void RemoveAlignments(final Vector<InfoAlignment> toRemove) {
      final int size=toRemove.size();
      SwingWorker<Integer, InfoAlignment> infoSwingWorker=new SwingWorker<Integer, InfoAlignment>()  {

       @Override
        protected Integer doInBackground() throws Exception {
            //--Commit only at the end...
            df.setAutoCommit(false);
            for(int i=0; i<size;i++) {
                InfoAlignment tmp=toRemove.get(i);
                tmp.removeFromDatabase();
                publish(tmp);
                setProgress(i*100/size);
            }
            df.setAutoCommit(true);
            return 0;
            }

            //Update list of InfoSequence
            @Override
            protected void process(List<InfoAlignment> chunks) {
                for (InfoAlignment tmp:chunks) MultipleInfoAlignment.remove(tmp);
            }


           @Override
           protected void done(){
                loading.setVisible(false);
                loadInfoAlignment();
           }

        }; //End SwingWorker declaration

        infoSwingWorker.addPropertyChangeListener(
                 new PropertyChangeListener() {
                    public  void propertyChange(PropertyChangeEvent evt) {
                     if ("progress".equals(evt.getPropertyName())) {
                            SwingWorker o = (SwingWorker)evt.getSource();
                            if (!o.isDone()) {
                                int progress=(Integer)evt.getNewValue();
                                loading.setProgress(progress);
                            }
                            else if (o.isDone()&&!o.isCancelled()) {
                               //Handled in done() fucntion in SwingWorker
                            }
                        }//End progress update
                 } //End populateNetworkPropertyChange
                 });
        loading=new InformationJDialog(this, false, infoSwingWorker, "Removing alignment(s)");
        loading.setProgress(0); //Put 0% as the start progress
        loading.Message("Removing "+size+" alignment(s) from database...", "");
        infoSwingWorker.execute();
    }



/**
 * This function load all the sequences in the database and
 * display them in the JTable
 */
public void updateUI() {
    
    //--Put them in the table
       InfoAlignmentTableModel tm=(InfoAlignmentTableModel)this.jTable1.getModel();
       tm.data.clear();
       tm.setData(MultipleInfoAlignment);
        tm.fireTableDataChanged();
        this.jTable1.setModel(tm);
    //--Display some information
    Message("Currently "+MultipleInfoAlignment.size()+" alignments in database.","", this.jStatusMessageSequence);
    //Put group information in filter ComboBox;
    this.Filter_ComboBox.setModel(new DefaultComboBoxModel(Config.ClusteringOption));
    //for (String S: df.getGroup()) this.Filter_ComboBox.addItem(S);
    for (String S: df.getMultipleAlignmentsGroup()) this.Filter_ComboBox.addItem(S);
}

///////////////////////////////////////////////////////////////////////////////
/// Search function
   /**
    * Fonction mode text et graphique
    * Note: Par design, on retourne les sequences dont la recherhce (voir mode)
    * "matches" un certains regex (pratique pour des applications de type AJAX )
    * Note2: On assigne aussi a la variable lastSearch des informations sur la recherche
    * @return A vector of the Index position of Matching result
    */
    Vector<Integer> search (String regex, int mode) {
        Vector<Integer> returnArray = new Vector<Integer>();
        Pattern p;
        try {
            p = Pattern.compile(regex, Pattern.CASE_INSENSITIVE);
        } catch(java.util.regex.PatternSyntaxException e) {return returnArray;}
        int search_len=0;
        try {
            search_len=Integer.valueOf(regex);
        } catch (Exception e) {search_len=0;}
        switch (mode) {
            case MODE_ID:       lastSearch="Id with: "+regex;
                                for (int i=0; i<MultipleInfoAlignment.size();i++) {
                                      InfoAlignment data=MultipleInfoAlignment.get(i);
                                      Matcher m = p.matcher(""+data.getId());
                                      if (m.find()) returnArray.add(i);
                                }
                                break;           
            case MODE_DESC:  lastSearch="Description with: "+regex;
                                for (int i=0; i<MultipleInfoAlignment.size();i++) {
                                      InfoAlignment data=MultipleInfoAlignment.get(i);
                                       Matcher m = p.matcher(data.getName());
                                      if (m.find()) returnArray.add(i);
                                }
                                break;
            case MODE_LENMORE: lastSearch="Len(bp) greater: "+regex;
                                for (int i=0; i<MultipleInfoAlignment.size();i++) {
                                    InfoAlignment data=MultipleInfoAlignment.get(i);
                                    try {
                                        int len=data.getSize();
                                        if (len>=search_len) returnArray.add(i);
                                    } catch(Exception e) {}
                                }
                                break;
             case MODE_LENLESS: lastSearch="Len(bp) greater: "+regex;
                                for (int i=0; i<MultipleInfoAlignment.size();i++) {
                                    InfoAlignment data=MultipleInfoAlignment.get(i);
                                    try {
                                        int len=Integer.valueOf(data.getSize());
                                        if (len<=search_len) returnArray.add(i);
                                    } catch(Exception e) {}
                                }
                                break;
            case MODE_ALL:      lastSearch="All with: "+regex;
                                for (int i=0; i<MultipleInfoAlignment.size();i++) {
                                    InfoAlignment data=MultipleInfoAlignment.get(i);
                                    Matcher m3 = p.matcher(data.getName());
                                    Matcher m4 = p.matcher(data.getNote());
                                    Matcher m5 = p.matcher(String.valueOf(data.getSize())); //TO DO: Sequence search
                                    if (m3.find()||m4.find()||m5.find()) returnArray.add(i);
                                }
        } //end switch
        Config.log("Searching for "+lastSearch);
        System.out.printf(" found %d result(s)\n", returnArray.size());
        return returnArray;
      }

    /**
     * This display the sequence box
     */
    public void display() {
        //--Get the number of sequence
        Alignment s=new Alignment();
        s.hasNext();
        //--Reload sequence if no sequences loadded or new sequence added...
         if (MultipleInfoAlignment.size()==0||MultipleInfoAlignment.size()!=s.getAllId().size()) loadInfoAlignment();
         setVisible(true);
    }

    /**
     * If in selection mode: used to know if we can get a sequence
     * @return
     */
    public int getStatus() {
        return this.status;
    }
    
    public int getSequenceID() {
        return this.return_sequence_id;
    }

    // Variables declaration - do not modify//GEN-BEGIN:variables
    private javax.swing.JButton Close_jButton;
    private javax.swing.JComboBox Filter_ComboBox;
    private javax.swing.JButton MakeCollectionjButton;
    private javax.swing.JButton RemoveFromGroupSequence_jButton;
    private javax.swing.JButton RemoveSequence_jButton;
    private javax.swing.JButton SelectUnselectSequence_jButton;
    private javax.swing.JMenuItem SelectUnselectSequence_jMenuItem;
    private javax.swing.JPanel Sequence_Panel;
    private javax.swing.JLabel jLabel1;
    private javax.swing.JMenu jMenu1;
    private javax.swing.JMenu jMenu2;
    private javax.swing.JMenuBar jMenuBar1;
    private javax.swing.JMenuItem jMenuItem1;
    private javax.swing.JMenuItem jMenuItem2;
    private javax.swing.JMenuItem jMenuItem3;
    private javax.swing.JMenuItem jMenuItem4;
    private javax.swing.JPanel jPanel29;
    private javax.swing.JScrollPane jScrollPane1;
    private javax.swing.JTextField jStatusMessageSequence;
    private javax.swing.JTable jTable1;
    // End of variables declaration//GEN-END:variables

}
